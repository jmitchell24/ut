namespace ut
{
    template struct basic_strview<char, std::char_traits<char>, false>;
    template struct basic_strview<char, std::char_traits<char>, true>;

    template struct basic_strview_split<true, char, std::char_traits<char>>;
    template struct basic_strview_split<false, char, std::char_traits<char>>;

    template struct basic_strview_buf<char, std::char_traits<char>>;
    template struct basic_strview_stream<char, std::char_traits<char>>;
}

template <typename T, float LF> struct hash_table
{
    struct entry
    {
        std::string key;
        bool empty=true;
        union { char dummy; T value; };
    };

    static constexpr float LOAD_FACTOR = LF;
    static_assert(LOAD_FACTOR > 0 && LOAD_FACTOR < 1, "invalid LOAD_FACTOR range");

    using entries_type = std::vector<entry>;

    entries_type buckets;
    size_t count = 0;

    inline size_t bucketIndex(strparam key)
    { return hasher::range(key.begin(), key.end()) % buckets.size(); }

    bool set(strparam key, T&& value)
    {
        if (count+1 > buckets.size() * 0.75)
        {
            buckets.reserve(buckets.capacity() * 1.5);
        }

        entry* e = findEntry(key);

        bool is_new = e->empty;
        if (is_new) ++count;

        e->key = key.str();
        e->operator=(value);
        return is_new;
    }

    entry* findEntry(strparam key)
    {
        size_t index = bucketIndex(key);

        for (;;)
        {
            auto entry = &buckets[index];
            if (entry->key == key.str() || entry->empty)
                return entry;
            index = (index + 1) % buckets.size();
        }
    }

    static hash64_t hash(strparam s)
    {
        return hasher::range(s.begin(), s.end());
    }
};
